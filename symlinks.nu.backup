# Define device profiles and compatibility
# Each config lists which device types it's compatible with
const DEVICE_PROFILES = {
    vps: {
        description: "VPS - server-only configuration"
        excludes: ["hypr", "waybar", "tofi", "dunst", "foot", "kitty", "otd", "quickshell", "neovide"]
    }
    "arch-x64": {
        description: "Arch Linux x64 - full desktop environment"
        excludes: []  # All configs compatible
    }
    "arch-arm": {
        description: "Arch Linux ARM - full desktop (except neovide)"
        excludes: ["neovide"]
    }
    termux: {
        description: "Termux/Android - minimal config"
        excludes: ["hypr", "waybar", "tofi", "dunst", "foot", "kitty", "otd", "quickshell", "neovide", "zellij", "yazi", "atuin", "fastfetch", "crush", "aichat", "opencode"]
    }
}

# Configuration data with device compatibility and updated paths
const DATA = {
    aichat: {
        items: [ config.yaml ]
        compatible_with: ["vps", "arch-x64", "arch-arm"]
    }
    atuin: {
        items: [ config.toml ]
        compatible_with: ["vps", "arch-x64", "arch-arm"]
    }
    crush: {
        items: [ crush.json ]
        compatible_with: ["vps", "arch-x64", "arch-arm"]
    }
    dunst: {
        items: [ dunstrc ]
        compatible_with: ["arch-x64", "arch-arm"]
    }
    fastfetch: {
        items: [
            ascii.txt
            config.jsonc
        ]
        compatible_with: ["vps", "arch-x64", "arch-arm"]
    }
    foot: {
        items: [
            foot.ini
            cyberdream.ini
            cyberdream-light.ini
            tokyonight-storm.ini
        ]
        compatible_with: ["arch-x64", "arch-arm"]
    }
    home: {
        items: [
            { gitconfig: .gitconfig }
        ]
        compatible_with: ["vps", "arch-x64", "arch-arm", "termux"]
    }
    hypr: {
        items: [
            hyprland.conf
            hyprlock.conf
            hyprtoolkit.conf
            monitor.nu
            shaders/grayscale.glsl
        ]
        compatible_with: ["arch-x64", "arch-arm"]
    }
    kitty: {
        items: [
            kitty.conf
        ]
        compatible_with: ["arch-x64", "arch-arm"]
    }
    neovide: {
        items: [
            config.toml
        ]
        compatible_with: ["arch-x64"]  # Not on ARM or VPS
    }
    nvim: {
        target: ($nu.home-dir)/.config/nvim/lua
        items: [
            ulazy
            ulsp
            uinit.lua
            utils.lua
            # plugins
            unavigate
        ]
        compatible_with: ["vps", "arch-x64", "arch-arm", "termux"]
        message: 'Enable plugins by adding `.u.lua`: `return {LV = 1}`'
    }
    opencode: {
        items: [
            oh-my-opencode-slim.json
            opencode.jsonc
        ]
        compatible_with: ["vps", "arch-x64", "arch-arm"]
        message: 'Don'\''t forget to symlink /g/ai/skills to ($nu.home-dir)/.agents/skills'
    }
    otd: {
        target: ($nu.home-dir)/.config/OpenTabletDriver/Presets
        items: [
            "Deco 640 Artist Mode.json"
            "Deco 640 Absolute Mode.json"
        ]
        compatible_with: ["arch-x64", "arch-arm"]
    }
    quickshell: {
        items: [
            shell.qml
            u
        ]
        compatible_with: ["arch-x64", "arch-arm"]
    }
    tofi: {
        items: [
            config
        ]
        compatible_with: ["arch-x64", "arch-arm"]
    }
    waybar: {
        items: [
            config.jsonc
            style.css
        ]
        compatible_with: ["arch-x64", "arch-arm"]
    }
    zellij: {
        items: [
            config.kdl
            layouts/android-alx.kdl
            layouts/default.kdl
            layouts/minimal.kdl
            themes/cyberdream.kdl
            themes/cyberdream-light.kdl
        ]
        compatible_with: ["vps", "arch-x64", "arch-arm"]
        message: 'Execute this: http get https://github.com/dj95/zjstatus/releases/latest/download/zjstatus.wasm | save -f ($nu.home-dir)/.config/zellij/zjstatus.wasm'
    }
    nushell: {
        target: $nu.default-config-dir  # = ($nu.home-dir)/.config/($app_name)
        items: [
            u
            uinit.nu
            uconfig.nu
            uenv.nu
        ]
        compatible_with: ["vps", "arch-x64", "arch-arm", "termux"]
    }
    yazi: {
        items: []  # Add items if needed
        compatible_with: ["arch-x64", "arch-arm"]
    }
}

# Get repository root (where configs/ directory lives)
const REPO_ROOT = (path self | path dirname)

# Read device type from ~/.u.json
def get_device_type []: string -> string {
    let ujson_path = $"($nu.home-dir)/.u.json"
    
    if not ($ujson_path | path exists) {
        print $"(ansi yb)Warning: ~/.u.json not found, using default profile 'arch-x64'(ansi reset)"
        return "arch-x64"
    }
    
    let ujson = (open $ujson_path)
    let device_type = ($ujson | get device_type? | default "arch-x64")
    
    # Validate device type
    if $device_type not in (["vps", "arch-x64", "arch-arm", "termux"]) {
        print $"(ansi yb)Warning: Invalid device_type '($device_type)' in ~/.u.json, using default 'arch-x64'(ansi reset)"
        return "arch-x64"
    }
    
    return $device_type
}

# Check if a symlink exists and where it points
def get_symlink_target [symlink_path: string]: record {|symlink_exists: bool, symlink_target: string|} {
    if not ($symlink_path | path exists) {
        return { symlink_exists: false, symlink_target: "" }
    }
    
    let target = (^readlink $symlink_path | complete)
    if $target.exit_code != 0 {
        return { symlink_exists: false, symlink_target: "" }
    }
    
    return { symlink_exists: true, symlink_target: ($target.stdout | str trim) }
}

# Get symlink status for display
def get_symlink_status [app_name: string, config_path: string]: string {
    let items = ($DATA | get $app_name | get items)
    let target = ($DATA | get $app_name | get target? | default $"($nu.home-dir)/.config/($app_name)")
    
    # Check each item
    let mut status_parts = []
    $items | each {|$item|
        let item_path = match $item {
            record: $source_path => $source_path
            record: $target_file => [$REPO_ROOT "configs" $app_name $target_file] | path join
            string => [$REPO_ROOT "configs" $app_name $item] | path join
        }
        
        let item_name = match $item {
            record: $name => $name
            record: $target_file => $target_file
            string => $item
        }
        
        let symlink_target = [$target $item_name] | path join
        let symlink_info = (get_symlink_target $symlink_target)
        
        if not $symlink_info.symlink_exists {
            $status_parts = ($status_parts | append ["(ansi rd)✗(ansi reset) Not symlinked"])
        } else if ($symlink_info.symlink_target | path expand) != ($item_path | path expand) {
            $status_parts = ($status_parts | append ["(ansi yb)⚠(ansi reset) Wrong target"])
        } else {
            $status_parts = ($status_parts | append ["(ansi gr)✓(ansi reset) Symlinked"])
        }
    }
    
    return ($status_parts | str join " | ")
}

# Create symlink with validation
def create_symlink [app_name: string]: nothing {
    let config_data = ($DATA | get $app_name)
    let config_items = $config_data.items
    let target_dir = ($config_data.target? | default $"($nu.home-dir)/.config/($app_name)")
    
    print $"(ansi c)Processing ($app_name)...(ansi reset)"
    
    # Validate target directory exists
    if ($target_dir | path type) != "dir" {
        print $"(ansi rd)Error: Target is not a directory: ($target_dir)(ansi reset)"
        print $"(ansi yb)Tip: Create the directory manually or check permissions(ansi reset)"
        return
    }
    
    # Process each item
    $config_items | each {|$item|
        let item_source = match $item {
            record: $source_path => $source_path
            record: $target_file => [$REPO_ROOT "configs" $app_name $target_file] | path join
            string => [$REPO_ROOT "configs" $app_name $item] | path join
        }
        
        let item_name = match $item {
            record: $name => $name
            record: $target_file => $target_file
            string => $item
        }
        
        let item_target_dir = match $item {
            record: $source_path => [$target_dir $item_name] | path dirname | path expand
            string => [$target_dir] | path dirname | path expand
        }
        
        let item_target = [$target_dir $item_name] | path join
        let symlink_path = if ($item | describe) == "record" {
            $item_source  # For records, the target is where to symlink TO
        } else {
            $item_target  # For strings, item_target is where to symlink
        }
        
        # Validate item target directory exists
        if ($item_target_dir | path type) != "dir" {
            print $"  (ansi rd)✗(ansi reset) Skipping ($item_name): Target directory doesn't exist: ($item_target_dir)"
            return
        }
        
        # Check existing symlink
        let symlink_info = (get_symlink_target $item_target)
        
        if $symlink_info.symlink_exists {
            # Symlink exists, check if it points to correct location
            let expected_target = ($item_source | path expand)
            let current_target = ($symlink_info.symlink_target | path expand)
            
            if $current_target != $expected_target {
                print $"  (ansi yb)⚠(ansi reset) Existing symlink points to: ($symlink_info.symlink_target)"
                print $"  (ansi yb)⚠(ansi reset) Expected: ($item_source)"
                print $"  (ansi yb)⚠(ansi reset) Removing and recreating...(ansi reset)"
                ^rm -f $item_target
            }
        }
        
        # Create symlink
        ^ln -sf $item_source $item_target
        print $"  (ansi gr)✓(ansi reset) Symlinked: ($item_name)"
    }
    
    # Display post-setup message if present
    if ($config_data.message? | is-not-empty) {
        print $"(ansi rb)($config_data.message)(ansi reset)"
    }
}

# Get compatible configs for current device
def get_compatible_configs [device_type: string]: list<string> {
    let profile_excludes = ($DEVICE_PROFILES | get $device_type | get excludes | default [])
    
    $DATA | columns | where {|$app_name|
        let app_data = ($DATA | get $app_name)
        not ($app_name in $profile_excludes)
    }
}

# Interactive multi-select menu
def interactive_menu []: nothing {
    let device_type = (get_device_type)
    let profile_desc = ($DEVICE_PROFILES | get $device_type | get description)
    
    print $""
    print $"(ansi c)Symlink Configuration Manager"
    print $"(ansi c)Device Profile: (ansi yb)($device_type)(ansi c) - ($profile_desc)"
    print $""
    
    let compatible_apps = (get_compatible_configs $device_type)
    
    # Build menu items with status
    let menu_items = []
    $compatible_apps | each {|$app_name|
        let status = (get_symlink_status $app_name [$REPO_ROOT "configs" $app_name])
        $menu_items = ($menu_items | append { name: $app_name, status: $status })
    }
    
    if ($menu_items | is-empty) {
        print $"(ansi rd)No compatible configurations found for device type: ($device_type)(ansi reset)"
        return []
    }
    
    # Display menu
    print $"(ansi c)Available configurations (use arrows to navigate, Space to select, Enter to confirm):(ansi reset)"
    print $""
    $menu_items | enumerate | each {|$item|
        let status_str = if $item.index < 9 { " " } else { $"($item.index + 1)" }
        print $"(ansi c)($status_str) (ansi reset) ($item.item.name) - ($item.item.status)"
    }
    
    print $""
    
    # Get user selection
    let selection = (input list --multi $menu_items | get name)
    
    if ($selection | is-empty) {
        print $"(ansi rd)No configurations selected.(ansi reset)"
        return []
    }
    
    return $selection
}

# App name completion
def app_completion []: list<string> {
    let device_type = (get_device_type)
    get_compatible_configs $device_type
}

# Check if a value is a record (for record items in DATA)
def is-record []: any -> bool {
    ($in | describe) == "record"
}

# Main function
export def main [
    app_name?: string@app_completion
] {
    let device_type = (get_device_type)
    let profile_desc = ($DEVICE_PROFILES | get $device_type | get description)
    
    # Single-app mode (backward compatible)
    if ($app_name? | is-not-empty) {
        # Check if app is compatible with current device
        let app_data = ($DATA | get $app_name)
        let compatible_with = ($app_data.compatible_with? | default ["arch-x64"])
        
        if not ($device_type in $compatible_with) {
            print $"(ansi rd)Error: ($app_name) is not compatible with device type: ($device_type)(ansi reset)"
            print $"(ansi yb)Compatible device types: ($compatible_with | str join ', ')(ansi reset)"
            print $"(ansi yb)Current device: ($device_type) - ($profile_desc)(ansi reset)"
            return
        }
        
        print $"(ansi c)Symlinking (ansi yb)($app_name)(ansi c) for device: (ansi yb)($device_type)(ansi c) - ($profile_desc)(ansi reset)"
        create_symlink $app_name
        return
    }
    
    # Multi-select mode
    let selected_apps = (interactive_menu)
    
    if ($selected_apps | is-empty) {
        return
    }
    
    print $""
    print $"(ansi c)Selected ($selected_apps | length) configuration(s): ($selected_apps | str join ', ')(ansi reset)"
    print $""
    
    # Symlink all selected configs in parallel
    let results = $selected_apps | par-each {|$app_name|
        try {
            create_symlink $app_name
            return { app: $app_name, success: true, error: "" }
        } catch { |err|
            return { app: $app_name, success: false, error: $err.msg }
        }
    }
    
    # Display summary
    print $""
    print $"(ansi c)Summary"
    print $""
    
    let successful = ($results | where success)
    let failed = ($results | where not success)
    
    if ($successful | is-not-empty) {
        print $"(ansi gr)✓(ansi reset) Successfully symlinked: ($successful | get app | str join ', ')"
    }
    
    if ($failed | is-not-empty) {
        print $""
        print $"(ansi rd)✗(ansi reset) Failed to symlink:(ansi reset)"
        $failed | each {|$result|
            print $"  (ansi rd)✗(ansi reset) ($result.app): ($result.error)"
        }
    }
    
    print $""
    print $"(ansi c)Done! Run this script again to modify symlinks.(ansi reset)"
}
